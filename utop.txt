open Magic_tree_fitter.Core_algo;;
open Magic_tree_fitter.Domain_types;;
open Magic_tree_fitter.Grammar_reader;;
open Magic_tree_fitter.Symbol_table;;
open Magic_tree_fitter.Parse_table_constructor;;
open Magic_tree_fitter.Grammar_reader_utils;;
open Magic_tree_fitter.Dump;;
open Magic_tree_fitter.Gss;;
open Magic_tree_fitter.Graph;;
open Magic_tree_fitter.Stack;;
open Magic_tree_fitter.Graph_monad_ops;;
open Magic_tree_fitter.Stack_monad_ops;;
open Magic_tree_fitter.Stack_ops;;
open Magic_tree_fitter.Glr_utils;;

open Yojson.Basic.Util;;

let parse_tables = "grammars/lisp.g4" |> extract_grammar |> create_parse_tables;;
let config, initial_graph = setup_glr parse_tables;;
let c,g = run_glr initialise_stacks config initial_graph;;

g.stacks |> List.length;;
let s1 = List.nth g.stacks 0;;
dump_nodes s1;;
print_stack_top s1;;

   let updated_stacks =
      List.map
        (fun s ->
           let s', _ = Stack.(run_stack (apply_actions_to_stack c) s) in
           Printf.printf "After apply_actions_to_stack:\n";
           print_stack_top s';
           s')
        g.stacks
      |> (fun sl ->
      if g.forward_tokens = [] || g.reverse_tokens = []
      then sl
      else (
        let curr_forward_token = List.hd g.forward_tokens in
        let curr_backward_token = List.hd g.reverse_tokens in
        List.map
          (fun s ->
             { s with
               next_token =
                 (if s.direction = Forward
                  then curr_forward_token
                  else curr_backward_token)
             })
          sl))
      |> List.map (update_stack_with_actions c)
      |> List.filter (fun s -> not (NodeMap.is_empty s.top))


updated_stacks |> List.length;;
let s' = List.nth updated_stacks 0;;
dump_nodes s';;
print_stack_top s';;


    let g' =
      { g with
        stacks =
          List.map
            (fun s ->
               { s with
                 next_token =
                   (if s.direction = Forward
                    then curr_forward_token
                    else curr_backward_token)
               })
            updated_stacks
      };;


g'.stacks |> List.length;;
let s2 = List.nth g'.stacks 0;;
dump_nodes s2;;
print_stack_top s2;;


    let g' =
      { g with
        forward_tokens = List.tl g.forward_tokens
      ; reverse_tokens = List.tl g.reverse_tokens
      }


updated_stacks_2 |> List.length;;
let s'' = List.nth updated_stacks_2 0;;
dump_nodes s'';;
print_stack_top s'';;
