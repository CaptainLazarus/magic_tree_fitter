open Magic_tree_fitter.Core_algo;;
open Magic_tree_fitter.Domain_types;;
open Magic_tree_fitter.Grammar_reader;;
open Magic_tree_fitter.Symbol_table;;
open Magic_tree_fitter.Parse_table_constructor;;
open Magic_tree_fitter.Grammar_reader_utils;;
open Magic_tree_fitter.Dump;;
open Magic_tree_fitter.Gss;;
open Magic_tree_fitter.Graph;;
open Magic_tree_fitter.Stack;;
open Magic_tree_fitter.Graph_monad_ops;;
open Magic_tree_fitter.Stack_monad_ops;;
open Magic_tree_fitter.Stack_ops;;
open Magic_tree_fitter.Glr_utils;;

open Yojson.Basic.Util;;

let parse_tables = "grammars/lisp.g4" |> extract_grammar |> create_parse_tables;;
let config, initial_graph = setup_glr parse_tables;;
let c,g = run_glr initialise_stacks config initial_graph;;


g.stacks |> List.length;;
let s1 = List.nth g.stacks 0;;
dump_nodes s1;;
print_stack_top s1;;

(*
let g2, g2' = run_glr construct_ast 0 c g


   let updated_stack =
      NodeMap.fold
        (fun _ top_node s -> run_stack (apply_top_node_actions c top_node) s |> snd)
        s1.top
        s1
*)
(*
let  s2 = consume_token c s1 |> snd;;
dump_stack s2;;
*)
let updated_stacks =
        List.map
          (fun s ->
             let s', _ = Stack.(run_stack (consume_token c) s) in
             s')
          g.stacks
        (* FIX : I need to advance the token here. Updating here makes no sense *)
        |> List.map (update_stack_next_token g)
        |> List.map (update_stack_with_actions c)
        |> List.filter (fun s -> not (NodeMap.is_empty s.top))

 let g' =
        { stacks = updated_stacks
        ; forward_tokens =
            (if g.forward_tokens = [] then [] else List.tl g.forward_tokens)
        ; reverse_tokens =
            (if g.reverse_tokens = [] then [] else List.tl g.reverse_tokens)
        }

let updated_stacks =
        List.map
          (fun s ->
             let s', _ = Stack.(run_stack (consume_token c) s) in
             s')
          g'.stacks
        (* FIX : I need to advance the token here. Updating here makes no sense *)
;;
List.iter dump_stack updated_stacks;;

        |> List.map (update_stack_next_token g')
        |> List.map (update_stack_with_actions c)
        |> List.filter (fun s -> not (NodeMap.is_empty s.top))

    let g'' =
        { stacks = updated_stacks
        ; forward_tokens =
            (if g'.forward_tokens = [] then [] else List.tl g'.forward_tokens)
        ; reverse_tokens =
            (if g'.reverse_tokens = [] then [] else List.tl g'.reverse_tokens)
        }

